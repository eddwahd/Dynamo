\documentclass[aps, pra, a4paper, longbibliography, superscriptaddress]{revtex4-1}

\usepackage[utf8]{inputenc}
%\usepackage[T1]{fontenc}
\usepackage[australian]{babel}
\usepackage{graphicx, hyperref, amsmath, amssymb, verbatim}

\newcommand{\I}{\openone}
\newcommand{\be}{\begin{equation}}
\newcommand{\ee}{\end{equation}}
\newcommand{\eq}{\Leftrightarrow}

\newcommand{\R}{{\mathbb R}}  % real numbers
\newcommand{\C}{{\mathbb C}}  % complex numbers

\newcommand{\ket}[1]{\left| #1 \right \rangle}
\newcommand{\bra}[1]{\left \langle #1 \right|}
\newcommand{\braket}[2]{\left \langle #1 | #2 \right \rangle}
\newcommand{\ketbra}[2]{\left| #1 \right \rangle \left \langle #2 \right|}
\newcommand{\comm}[2]{\left[ #1, #2 \right]}
\newcommand{\inprod}[2]{\left\langle #1, #2 \right\rangle}

\newcommand{\hilb}[1]{\mathcal{#1}}

\DeclareMathOperator{\tr}{tr}
\DeclareMathOperator{\re}{Re}
\DeclareMathOperator{\cvec}{vec}

\newcommand{\dd}[2]{\frac{\partial #1}{\partial #2}}

% TODO Dynamo vs DYNAMO
\newcommand{\DYNAMO}{\textsc{dynamo}}

% TODO final vs target, maybe X_n should be X_final
\begin{document}
\title{DYNAMO manual}
\date{\today}

\author{Ville Bergholm}
\email{ville.bergholm@iki.fi}
\affiliation{Department of Chemistry, Technische Universität München, Germany}
\affiliation{ISI Foundation, Via Alassio 11/c, 10126 Torino, Italy}

% \pacs{}
% \keywords{tensor network, invariant} not needed as they are embedded into the PDF.  

\begin{abstract}
\DYNAMO{}...
\end{abstract}
\maketitle



\tableofcontents


\section{Introduction}

For the scientific background to \DYNAMO{}, see~\cite{machnes_2011}.



\section{Basics}
% TODO the word system is used for both S alone and the whole thing
The \DYNAMO{} package is designed to handle different types of bilinear
control system optimization problems.
All these problems can be described using a linear master equation of
the following form:
\be
\label{eq:master}
\dot{X}(t) = \underbrace{\left(A(t) +\sum_{c} u_c(t) B_c\right)}_{G(t)} X(t) = G(t) X(t),
\ee
where $u_c$~are the (scalar) \emph{control fields}, $B_c$~the
corresponding \emph{control generators},
$A$~the \emph{drift} generator, $X$~the state of the system (vector or operator),
and $G$~the total generator.
% NOTE We used to have a minus sign in front of~$G$ as a convention, not any more.
Depending on the problem,
$X$~can be related to either an abstract
vector space, a quantum mechanical Hilbert state space,
or a Liouville space.
We use the $\cvec$-representation of state
operators, explained in Appendix~\ref{sec:vec},
as the mapping between the Hilbert and Liouville spaces.

The optimization problems can be divided into three categories:
\begin{itemize}
\item
abstract linear systems
\item
closed quantum systems (unitary evolution generated by a Hamiltonian)
\item
open quantum systems coupled to Markovian baths (Lindblad-form
evolution generated by a Liouvillian)
\end{itemize}
In the quantum cases the system may be divided into the system
proper~$S$ and an an environment~$E$ coupled to it.
The evolution of the compound system $S+E$ is treated
fully quantum mechanically enabling non-Markovian recurrence effects,
but in the end we are only interested in the state of~$S$.



\subsection{Piecewise-defined controls}

% sum over control fields: c
% sum over time slices: k
Assume that the controls are
piecewise constant\footnote{Actually ``piecewise defined'' might be
  enough, if the controls are not constant it's just the computation
  of the propagators~$P_k$ for each slice that gets harder.}
in time: $u_{c, k}$, with $n$~time slices in total,
and that the duration of the $k$th slice is~$\tau_k$.
The points in time where the controls may change in value are thus
\be
t_k = t_0 + \sum_{j=1}^{k} \tau_j, \quad k \in \{0, \ldots, n\}.
\ee
For each time slice we now obtain the propagator
\be
P_k := \exp(G_k \tau_k),
\ee
with
\be
\label{eq:Xn}
X_k := X(t_k) = \prod_{j=1}^{k} P_j X(t_0).
\ee
The propagators, like the generators, always act on~$X$ by multiplication
from the left.
Furthermore, let us define the system and adjoint system propagators:
\begin{align}
U_k &:= P_k \cdots P_1,\\      % U_k X_0 = X_k
\Lambda_k &:= P_n \cdots P_{k+1}.
\end{align}
The relationship between the time slots and the related operators is
illustrated in Table~\ref{table:slices}.


Derivatives:
\begin{align}
\dd{P_k}{\tau_k}  &= G_k P_k = P_k G_k,\\
\dd{P_k}{u_{c,k}}
&=
\sum_{j=0}^{\infty} \frac{(\tau_k)^j}{j!}
\sum_{q=0}^{j-1}
G_k^{q} \dd{G_k}{u_{c,k}} G_k^{j-q-1}
=
\sum_{j=0}^{\infty} \frac{(\tau_k)^j}{j!}
\sum_{q=0}^{j-1}
G_k^{q} B_c G_k^{j-q-1}
\approx \tau_k B_c P_k.
\end{align}
The approximation is exact if $\comm{B_c}{G_k} = 0$.


\begin{table}[h]
\label{table:slices}
\[
\begin{array}{c}
\begin{array}{@{t_0}p{1.9em}@{t_1}p{1.8em}@{t_2}p{1.4em}@{t_{k-1}}p{1.1em}@{t_{k}}p{1.1em}@{t_{k+1}}p{0.8em}@{t_{n-2}}p{0.8em}@{t_{n-1}}p{1.3em}@{t_n}}
& & & & & & &
\end{array}\\
\begin{array}{|p{2em}|p{2em}|p{2em}|p{2em}|p{2em}|p{2em}|p{2em}|p{2em}|}
 $\tau_1$ & $\tau_2$ & & $\tau_k$ & $\tau_{k+1}$ & & $\tau_{n-1}$ & $\tau_n$ \\
% $u_{c,1}$ & $u_{c,2}$ & & $u_{c,k}$ & $u_{c,k+1}$ & & $u_{c,n-1}$ & $u_{c,n}$ \\
 $P_1$ & $P_2$ & $\cdots$ & $P_k$ & $P_{k+1}$ & $\cdots$ & $P_{n-1}$ & $P_n$ \\
\cline{1-4}
& & & $U_{k}$ & $\Lambda_{k}$ & & & \\
\cline{5-8}
\end{array}
\end{array}
\]
\caption{Time slices and operators related to them.
$t_k = t_0 + \sum_{j=1}^{k} \tau_j$.
The total forward and backward
propagators to the point $t_k$ are defined as
$U_k = P_k \cdots P_1$ and
$\Lambda_k = P_{n} \cdots P_{k+1}$.}
\end{table}








\section{Optimization}

In what follows, all quantum states are assumed to be normalized to
unity. $\dim \hilb{H}$~is the dimension of the Hilbert space~$\hilb{H}$ of the system.
The results of this section are summarized in Table~\ref{table:tasks}.

Within each type of system we have several possible optimization tasks.
We usually wish to minimize an operator/vector distance between an
initial state $X(t_0) := X_i$ propagated in time to~$t_n$ and a final state~$X_f$.
The distance is measured using the Frobenius norm:
\be
d^2(A, B) = |A-B|^2
= \inprod{A-B}{A-B}
%=\tr((A-B)^\dagger (A-B))
%= |A|^2 +|B|^2 -\tr(A^\dagger B) -\tr(B^\dagger A)
%= |A|^2 +|B|^2 -2 \re \tr(A^\dagger B).
= |A|^2 +|B|^2 -2 \re \inprod{A}{B}.
\ee
Dividing this expression with the target norm squared~$|A|^2$ (assumed fixed,
known), we obtain the normalized distance measure
\be
\label{eq:df}
D(A,B)
:= \frac{d^2(A, B)}{|A|^2}
= 1 +\frac{|B|^2}{|A|^2} -2 f(A, B),
\ee
where
\be
f(A, B)
:= \frac{1}{|A|^2} \re \inprod{A}{B}
= \frac{1}{|A|^2} \re \tr(A^\dagger B)
\ee
is the normalized \emph{fidelity}\footnote{
There is another widely used quantity called fidelity in quantum information science which is different from the present one.}.
If $A$ and $B$ are Hermitian, $\re$ is unnecessary and the fidelity corresponds to an inner product.
% NOTE fidelity is the real part of an inner product, one can use Cauchy-Schwarz inequality...
Clearly $f(A, A) = 1$, and
the triangle inequality $|A-B| \le |A|+|B|$ yields
\be
\left(1 -\frac{|B|}{|A|} \right)^2 \le D(A, B) \le \left(1 +\frac{|B|}{|A|} \right)^2
\qquad \text{and} \qquad
|f(A, B)|
\le \frac{|B|}{|A|}
%\le \frac{1}{2} \left(1 +\frac{|B|^2}{|A|^2} \right)
\ee
since $f(A, -B) = -f(A, B)$.


Is minimum distance equivalent to maximum fidelity?
If $|A|^2$ and $|B|^2$ are constant
from Eq.~\eqref{eq:df} we can see that this clearly holds.






\begin{table}
\begin{tabular}{ll|c|c|l|l|l|l}
& & task & space & $X_i$ & $X_f$ & $|X|^2$ & error function\\
\hline
Abstract &
& $\ket{v_i} \to \ket{v_f}$ & V
& $\ket{v_i}$ &$\ket{v_f}$ & $\braket{v}{v}$ & $E_\text{full}$\\
& & $U_i \to U_f$ & V
& $U_i$ & $U_f$ & $\tr(U^\dagger U)$ & $E_\text{full}$\\
\hline
Closed system & S
& $\ket{\psi_i} \to \ket{\psi_f}$ & H
& $\ket{\psi_i}$ & $\ket{\psi_f}$ & 1 & $E_\text{abs}$ (with phase: $E_\text{real}$)\\
%& $\rho_i \to \rho_f$ & L & $\cvec(\rho)$ & $P(\rho)$ & $E_\text{real}$\\
& & $\rho_i \to \rho_f$ & H
& $\rho_i$ & $\rho_f$ & $P(\rho)$ & $E_\text{real} + C$\\
%& $\rho_i \to \ketbra{\psi_f}{\psi_f}$ & H & $\rho$ & $P(\rho)$ & $E_\text{real}$ (overlap)\\
& & $U_i \to U_f$ & H
& $U_i$ & $U_f$ & $\dim \hilb{H}$ & $E_\text{abs}$ (with phase: $E_\text{real}$)\\
\hline
Closed system & SE
& $\rho_i \to \rho_f$ & H
& $\rho_i \otimes \rho_E$ & $\rho_f$ & $P(\rho)$ & $E_\text{partial}$\\
& & $U_i \to U_f$ & H
& $U_i \otimes \I_E$ & $U_f \otimes \I_E$ & $\dim \hilb{H}_S \dim \hilb{H}_E$ & $E_\text{tr}$\\
\hline
Open system & S
& $\rho_i \to \rho_f$ & L & $\cvec(\rho_i)$ & $\cvec(\rho_f)$ & $P(\rho)$ & $E_\text{full}$\\
& & $\rho_i \to \ketbra{\psi_f}{\psi_f}$ & L
& $\cvec(\rho_i)$ & $\cvec(\rho_f)$ & $P(\rho)$ & $E_\text{real}$ (overlap)\\
& & $F_i \to F_f$ & L & $F_i$ & $F_f$ & $|\tr(F^\dagger F)|^2$ & $E_\text{full}$\\
\hline
Open system & SE
& $\rho_i \to \rho_f$ & L
& $\cvec(\rho_i \otimes \rho_E)$ & $\rho_f$ & $P(\rho)$ & $E_\text{partial}$\\
& & $U_i \to U_f$ & L & TODO
\end{tabular}
\caption{Summary of the optimization tasks.}
\label{table:tasks}
\end{table}


\subsubsection*{Error functions}



\begin{align}
E_\text{real}(A, B) &:= 1 -\frac{1}{|A|^2} \re g(A, B),\\
E_\text{abs}(A, B) &:= 1 -\frac{1}{|A|^2} |g(A, B)|,\\
E_\text{full}(A, B) &:= \frac{1}{2}\left(1 +\frac{|B|^2}{|A|^2}\right) -\frac{1}{|A|^2} \re \tr(A^\dagger B),\\
E_\text{partial}(A, B) &:= E_\text{full}(A, \tr_E(B)),\\
E_\text{tr}(A, B) &:= 1 -\frac{1}{|A|^2} \left\|Q(A, B)\right\|_{\tr}
= 1 -\frac{1}{|A|^2} \tr \sqrt{Q^\dagger Q},
\end{align}
with the auxiliary functions
\begin{align}
g(A, B) &:= \tr(A^\dagger B),\\
Q(A, B) &:= \tr_S\left(A^\dagger B\right).
\end{align}

All of these functions and their gradients can be efficiently computed
using the $U$s and $\Lambda$s
for any $j, k \in \{0, \ldots, n\}$:
\begin{align}
g(X_f, X_n) &= \tr(X_f^\dagger \Lambda_k U_k X_i)
= \tr(\Lambda'_{k+1} U'_{k+1}),\\
g(Y_f, Y_n) &= \tr(\Lambda_k^\dagger Y_f^\dagger \Lambda_k U_k Y_i U_k^\dagger)
= \tr(\Lambda'_{k+1} U'_{k+1}),\\
E_\text{full}(X_f, X_n) &= \frac{1}{2}\left(1 +\frac{|\Lambda_j U_j X_i|^2}{|X_f|^2}\right) -\frac{1}{|X_f|^2} \re \tr(X_f^\dagger \Lambda_k U_k X_i)
= \frac{1}{2}\left(1 +\frac{|\Lambda'_{j+1} U'_{j+1}|^2}{|X_f|^2}\right) -\frac{1}{|X_f|^2} \re \tr(X_f^\dagger \Lambda'_{k+1} U'_{k+1}),\\
E_\text{partial}(X_f, X_n)
&= \frac{1}{2}\left(1 +\frac{|\tr_E(\Lambda'_{j+1} U'_{j+1})|^2}{|X_f|^2}\right) -\frac{1}{|X_f|^2} \re \tr(X_f^\dagger \tr_E(\Lambda'_{k+1} U'_{k+1})).
\end{align}


Gradients ($X_f$ is always constant):
\footnote{Note the $2 \re$ in the gradient expression  
for the special case of mixed state transfer in a closed system.}
\begin{align}
\dd{E_\text{real}(X_f,X_n)}{u}
&= -\frac{1}{|X_f|^2} \re \left( \dd{g}{u} \right),\\
\dd{E_\text{abs}(X_f,X_n)}{u}
&= -\frac{1}{|X_f|^2} \re \left(\frac{g^*}{|g|} \dd{g}{u} \right),\\
\dd{g(X_f, X_n)}{u} &= \tr(X_f^\dagger \Lambda_{k} \left(\dd{P_k}{u}\right) U_{k-1} X_i)
= \tr(\Lambda'_{k+1} \left(\dd{P_k}{u}\right) U'_{k}),\\
\dd{g(Y_f, Y_n)}{u} &= 2 \re \tr\left(\Lambda_k^\dagger Y_f^\dagger \Lambda_k \left(\dd{P_k}{u}\right) U_{k-1} Y_i U_{k-1}^\dagger P_k^\dagger \right)
= 2 \re \tr\left(\Lambda'_{k+1} \left(\dd{P_k}{u}\right) U'_{k} P_k^\dagger \right), \quad \text{and}\\
\dd{E_\text{full}(X_f, X_n)}{u}
&= \frac{1}{|X_f|^2} \re \tr\left((X_n-X_f)^\dagger \dd{X_n}{u}\right)
= \frac{1}{|X_f|^2} \re \tr\left((\Lambda_k U_k X_i -X_f)^\dagger  \Lambda_{k} \left(\dd{P_k}{u}\right) U_{k-1} X_i \right)\\
&= \frac{1}{|X_f|^2} \re \tr\left((\Lambda'_{k+1} U'_{k+1} -X_f)^\dagger  \Lambda'_{k+1} \left(\dd{P_k}{u}\right) U'_{k} \right),\\
\dd{E_\text{partial}(X_f, X_n)}{u}
&= \frac{1}{|X_f|^2} \re \tr\left((\tr_E(\Lambda'_{k+1} U'_{k+1}) -X_f)^\dagger  \tr_E(\Lambda'_{k+1} \left(\dd{P_k}{u}\right) U'_{k}) \right).
\end{align}
The form of these expressions leads us to cache slightly different objects with
each error function to speed up the computation, presented in table~\ref{table:UL}.


The gradient is given by
\be
\dd{E_\text{tr}(X_f, X_n)}{u}
= -\frac{1}{|X_f|^2} \re \tr \left(\left(\sqrt{Q^\dagger Q}\right)^{-1} Q^\dagger \dd{Q}{u}\right)
= -\frac{1}{|X_f|^2} \re \tr \left(V S^{-1} S U^\dagger \dd{Q}{u}\right),
\ee
where we have used the SVD $Q = U S V^\dagger$.



\begin{table}
\begin{tabular}{l|c|c}
error function & $U'_{k+1}$ = $X_k$ & $\Lambda'_{k+1}$\\
\hline
$E_\text{abs}$, $E_\text{real}$ & $U_k X_i$ & $X_f^\dagger \Lambda_k$\\
$E_\text{mixed}$ & $U_k Y_i U_k^\dagger$ & $\Lambda_k^\dagger Y_f^\dagger \Lambda_k$\\
$E_\text{full}$, $E_\text{partial}$ & $U_k X_i$ & $\Lambda_k$
\end{tabular}
\caption{Definitions of the cached objects $U'$ and $\Lambda'$ used in the MATLAB
  code. $k \in \{0, \ldots, n\}$.}
\label{table:UL}
\end{table}


\subsection{Closed system}

In a closed system, we work within the Hilbert space~$\hilb{H}$.
The generators~$G_k$ are antihermitian (Hamiltonians multiplied by~$i$)
and the propagators~$P_k$ are thus always
unitary. Consequently, the purity of a state is conserved.

As a variant of this setting,
we may have a system~$S$ coherently coupled to an
environment~$E$, but are only interested in~$S$.
The Hilbert space of the total system is
$\hilb{H} = \hilb{H}_S \otimes \hilb{H}_E$.


\subsubsection{Pure state transfer $\ket{\psi_i} \to \ket{\psi_f}$}
\label{sec:closed-pure}

%Maximize state overlap, essentially
$X = \ket{\psi} \in \hilb{H}$, a Hilbert space state vector.
The states are assumed normalized, such that $|X|^2 = \braket{\psi}{\psi} = 1$.
Since global phase has no physical significance, our error function is
\be
E(X_f, X_n) := \frac{1}{2} \min_{\phi \in \R} D(X_f, e^{i \phi} X_n)
= 1 -\max_{\phi \in \R} \re \left( e^{i \phi} \tr(X_f^\dagger X_n)\right)
= 1 -|\tr(X_f^\dagger X_n)|
= E_\text{abs}(X_f, X_n) \le 1.
\ee

\begin{comment}
This result can also be obtained using the mixed state formula in the
vec representation, with $\rho = \ketbra{\psi}{\psi}$ and thus
$X = \cvec(\rho) = \ket{\psi^*} \otimes \ket{\psi}$.
The fidelity diagram breaks into two pieces and
we obtain
\be
f(X_f, X_n)
= (\re) \left|(\tr) \bra{\psi_f}  P_n \cdots P_1 \ket{\psi_i} \right|^2.
\ee
with $0 \le f(X_f, X_n) \le 1$.
Thus the problem simplifies back into Hilbert space
(albeit with an extra absolute value squared in the expression for the fidelity), and we may equivalently
choose $X = \ket{\psi}$.
\end{comment}


If global phase matters (NOTE: this is unphysical), we may minimize
$D(X_f, X_n)$ directly:
\be
E(X_f, X_n)
:= \frac{1}{2} D(X_f, X_n)
= 1 -\re \tr(X_f^\dagger X_n)
= E_\text{real}(X_f, X_n) \le 2.
\ee



\subsubsection{Mixed state transfer $\rho_i \to \rho_f$}
\label{sec:closed-mixed}

To match the form of Eq.~\eqref{eq:master},
the state operators need to be treated as vectors in Liouville space,
$X~=~\cvec(\rho)$.
This approach is fairly inefficient though, since in a closed system the
propagators are always unitary and the full Liouville space is not
needed. Hence we make an exception here, and \emph{do not} follow Eq.~\eqref{eq:master}.
Instead, we define~$Y = \rho$, and remain within the Hilbert space.
This choice gives $|Y|^2 = \tr(\rho^2) = P(\rho)$, the purity of~$\rho$.
Eq.~\eqref{eq:master} is replaced by the von Neumann equation
\be
\dot{Y} = \comm{-G(t)}{Y(t)},
\ee
and instead of Eq.~\eqref{eq:Xn} we have
\be
Y_k = P_k \cdots P_1 Y_i P_1^\dagger \cdots P_k^\dagger.
\ee

The error function is
\be
E(Y_f, Y_n)
:= \frac{1}{2} D(Y_f, Y_n)
= \frac{1}{2}\left(1 +\frac{|Y_i|^2}{|Y_f|^2}\right) -\frac{1}{|Y_f|^2} \re \tr(Y_f^\dagger Y_n)
= E_\text{real}(Y_f, Y_n) +\frac{1}{2}\left(\frac{|Y_i|^2}{|Y_f|^2} -1\right).
\ee


\begin{comment}
%\footnote{It will of course turn out that this is equivalent to treating them as operators in Hilbert
%space, $X~=~\rho$ as far as the results are concerned.}
The goal here is to minimize state operator distance
$D(X_f, X_n) = D(\rho_f, \rho_n)$.
$|X|^2$~is equivalent to the purity of the state:
\be
|X|^2
= |\cvec(\rho)|^2
= |\rho|^2
= \tr(\rho^2)
= P(\rho).
\ee
Unitary propagation conserves purity, hence (X1) holds, and we can
simply maximize the fidelity
\be
f(X_f, X_n)
%= \frac{1}{P(\rho_f)} (\re) \tr(X_f^\dagger X_n)
= \frac{1}{P(\rho_f)} (\re) (\tr) \left( X_f^\dagger  P_n \cdots P_1 X_i \right).
\ee
Furthermore, the fidelity is strictly nonnegative since the
state operators are positive:
\be
0 \le f(X_f, X_n) \le \sqrt{\frac{P(\rho_i)}{P(\rho_f)}}.
\ee
If either $\rho_f$ or $\rho_i$ is pure,
$\rho = \ketbra{\psi}{\psi}$,
we have $|\rho|^2 = \braket{\psi}{\psi}^2 = 1$, and
the diagram simplifies by splitting up.
\end{comment}

In some cases we are only interested in maximizing the projection of
the state on a target pure state~$\rho_f = \ketbra{\psi_f}{\psi_f}$. In this case the natural error
function is
\be
E(Y_f, Y_n)
:= 1 -\bra{\psi_f} \rho_n \ket{\psi_f}
= 1 -\tr\left(\ketbra{\psi_f}{\psi_f} \rho_n \right)
= 1 -\re \tr\left(Y_f^\dagger Y_n\right)
= E_\text{real}(Y_f, Y_n) \le 1.
\ee
Since $|Y_n|^2 = |Y_i|^2$, this error function is completely equivalent to the previous one.


\subsubsection{Unitary propagator $\I \to U_f$}
\label{sec:closed-u}
In this task we wish to generate a unitary gate~$U_f$ up to global
phase, starting from the identity~\footnote{More generally, we may also try to find the evolution which effects
$U_i \to U_f$, but because of the cyclical invariance of the trace $U_i$ can be always combined into $U_f$.}.
$X$~is a unitary operator on~$\hilb{H}$, and
thus $|X|^2 = \tr(X^\dagger X) = \tr(\I) = \dim \hilb{H}$.

Since global phase does not matter, the error function is
\be
E(X_f, X_n)
:= \frac{1}{2} \min_{\phi \in \R} D(X_f, e^{i \phi} X_n)
= 1 -\max_{\phi \in \R} \frac{1}{|X_f|^2} \re \left( e^{i \phi} \tr(X_f^\dagger X_n)\right)
= 1 -\frac{1}{|X_f|^2}|\tr(X_f^\dagger X_n)|
= E_\text{abs}(X_f, X_n) \le 1.
\ee
\begin{comment}
We can also get rid of phase by explicitly lifting the problem into
Liouville space (see Eq.~\eqref{eq:L-unitary}),
$X = \hat{V} = V^* \otimes V$,
and then minimize the operator distance~$D(X_f, X_n)$.

Using Eq.~\eqref{eq:hat-product}, the norm squared is 
\be
|X|^2 = |\hat{V}|^2
= \tr(\hat{V}^\dagger \hat{V})
= |\tr(V^\dagger V)|^2
= |\tr(\I)|^2
= N^2.
\ee
This is constant, so (X1) holds and we may maximize the fidelity instead:
\be
f(X_f, X_n)
= \frac{1}{N^2} \re \tr \left(X_f^\dagger X_n \right)
%= \frac{1}{N^2} (\re) \left| \tr \left(V_f^\dagger V_n \right) \right|^2
= \frac{1}{N^2} (\re) \left| \tr \left(V_f^\dagger V_n \right) \right|^2.
\ee
It clearly obeys $0 \le f(X_f, X_n) \le 1$.
Much like in
Sec.~\ref{sec:closed-pure},
the problem simplifies back into Hilbert space, and we may equivalently
choose~$X = V$.
\end{comment}


If global phase matters (NOTE: unphysical), we may again directly minimize
$D(X_f, X_n)$:
\be
E(X_f, X_n)
:= \frac{1}{2} D(X_f, X_n)
= 1 -\frac{1}{|X_f|^2} \re \tr(X_f^\dagger X_n)
= E_\text{real}(X_f, X_n) \le 2.
\ee




\subsubsection{Partial state transfer $\rho_i \to \rho_f$}

In this case we have in addition to the system~$S$ an environment~$E$.
We want to transform the state~$\rho_i$ on $S$ into~$\rho_f$.
$Y$ is a state operator on~$\hilb{H}_{SE}$, and
the initial state is assumed to be of the
form~$Y_i = \rho_i \otimes \rho_E$.
We also define~$Y_f = \rho_f$.
Again, $|Y|^2 = P(\rho_{SE})$.
\be
E(\rho_f, Y_n)
:= \frac{1}{2} D(\rho_f, \tr_E(Y_n))
= \frac{1}{2}\left(1 +\frac{|\tr_E(Y_n)|^2}{|Y_f|^2)}\right) -\frac{1}{|Y_f|^2} \re \tr(\rho_f^\dagger \tr_E(Y_n))
= E_\text{partial}(Y_f, Y_n).
\ee


\subsubsection{Partial unitary propagator $\I \to U_f$}

We wish to generate a unitary gate~$U_f$ operating on $S$ up to global
phase, starting from the identity.
$X$ is a unitary operator on~$\hilb{H}_{SE}$, and
thus $|X|^2 = \dim \hilb{H}_S \dim \hilb{H}_E$.
Define $X_i = \I_S \otimes U_E$, with $U_E$ undefined at this point,
and $X_f = U_f \otimes \I_E$.
Following~\cite{kosut_2006,floether_2012}, we have
\begin{align}
\notag
E(U_f, X_n)
&:= \min_{\Phi \in \text{U}(M)} \frac{1}{2} D(U_f \otimes \Phi, X_n)
= 1 -\max_{\Phi \in \text{U}(M)} \frac{1}{|X_f|^2} \re \tr\left((U_f^\dagger \otimes \Phi^\dagger) X_n\right)\\
&= 1 -\frac{1}{|X_f|^2} \left\|Q(X_f, X_n)\right\|_{\tr}
%= 1 -\frac{1}{|X_f|^2} \tr \sqrt{Q^\dagger Q}
= E_\text{tr}(X_f, X_n).
\end{align}
Since the trace norm $\|\cdot\|_{\tr}$ is unitarily invariant, the
choice of $U_E$ does not matter and can be taken to be~$\I_E$.
% NOTE again we can do $U_i \to U_f$, and like before they will combine around the trace.

Note that when $\dim \hilb{H}_E = 1$, these expressions reduce to the ones in Sec.~\ref{sec:closed-u},
with $Q = g$.





\subsection{Open system with a Markovian bath}

In this case our system is coupled to a Markovian bath~$B$, and thus
we have to work in a Liouville space.
The generators~$G_k$ are Liouvillians, expressible in terms of
Hamiltonians and Lindblad operators.
Again, as in the closed system case, our total system may also consist of 
a system~$S$ coherently coupled to an environment~$E$.
We use the $\cvec$-representation of state
operators, explained in Appendix~\ref{sec:vec},
as the mapping between the Hilbert and Liouville spaces.

An important difference to the closed system case is that a general Markovian propagation
does not necessarily conserve purity and unitarity:
\be
|X_n|^2 = \tr\left(X_i^\dagger \left(\prod_{k=1}^{n} P_k\right)^\dagger \left(\prod_{k=1}^{n} P_k\right) X_i\right).
\ee
If $G_k$ is normal $\eq \quad [G_k, G^\dagger_k] = 0$, we have
\be
P_k^\dagger P_k
= \exp(\tau_k G^\dagger_k) \exp(\tau_k G_k)
= \exp(\tau_k (G_k^\dagger + G_k)).
\ee
If all the generators $G_k$ are antihermitian, this reduces to $\I$ and thus
$|X_n|^2 = \tr(X_i^\dagger X_i) = |X_i|^2$, but usually this is not
the case.
%(X1) is not satisfied and fidelity does not uniquely define the distance.



\subsubsection{State transfer $\rho_i \to \rho_f$}

$X~=~\cvec(\rho)$, a vector in Liouville space. Again, like in
Sec.~\ref{sec:closed-mixed}, we obtain
$|X|^2 = \tr(\rho^2) = P(\rho)$.

The correct error function is
\be
E(X_f, X_n)
:= \frac{1}{2} D(X_f, X_n)
%= \frac{1}{2}\left(1 +\frac{|X_n|^2}{|X_f|^2}\right) -\frac{1}{|X_f|^2} \re \tr(X_f^\dagger X_n)
= E_\text{full}(X_f, X_n).
\ee

If we are only interested in maximizing the projection of
the state on a target pure state~$\rho_f = \ketbra{\psi_f}{\psi_f}$, the natural error
function is
\be
E(X_f, X_n)
:= 1 -\bra{\psi_f} \rho_n \ket{\psi_f}
= 1 -\tr\left(\ketbra{\psi_f}{\psi_f} \rho_n \right)
= 1 -(\re) \tr\left(X_f^\dagger X_n\right)
= E_\text{real}(X_f, X_n) \le 1.
\ee



\subsubsection{General quantum map $\I \to F_f$}

$X$ is a general quantum map in the vec-representation on Liouville space.
A unitary target map~$U_f$ would be given by
$X_f = \hat{U_f}$, which yields $|X_f|^2 = (\dim \hilb{H})^2$.
However, the norm $|X_n|^2$ of the propagated operator
is not necessarily constant. The error function is again
\be
E(X_f, X_n)
:= \frac{1}{2} D(X_f, X_n)
= E_\text{full}(X_f, X_n).
\ee


\subsubsection{Partial state transfer $\rho_i \to \rho_f$}

We want to transform the state~$\rho_i$ on $S$ into~$\rho_f$.
$X$ is the vec-representation of a state operator on~$\hilb{H}_{SE}$.
Again, $|X|^2 = P(\rho_{SE})$.
The initial state is assumed to be of tensor product form.
We define $X_i = \cvec(\rho_i \otimes \rho_E)$,
and~$X_f = \rho_f$.
The error is obtained using a partial trace over~$E$:
\be
E(\rho_f, X_n)
:= \frac{1}{2} D(\rho_f, \tr_E(X_n))
= \frac{1}{2}\left(1 +\frac{|\tr_E(X_n)|^2}{|X_f|^2}\right)
-\frac{1}{|X_f|^2} \re \tr(\rho_f^\dagger \tr_E(X_n))
= E_\text{partial}(X_f, X_n).
\ee



\subsubsection{Partial unitary propagator $\I \to U_f$}

TODO




\section{Package contents}

\DYNAMO{} consists of four major classes used to store the data of an
optimization problem, various utility functions, unit tests and examples.

\subsection{Main classes}

The four main classes are 
\begin{itemize}
\item
\emph{dynamo}: main container object, contains instances of the other classes

\item
\emph{qsystem}: describes the bilinear control system (usually a quantum system, hence the name)

\item
\emph{control\_seq}: stores a control sequence along with all the transformations applied on it

\item
\emph{cache}: takes care of the heavy computing (propagators etc.), caches the results
\end{itemize}

\subsubsection{Dynamo class}

The dynamo class is the main container object for a control optimization problem and possibly its solution.
It contains an instance of the qsystem, control\_seq and cache classes, plus some other data.
\begin{itemize}
\item
\emph{dynamo}: constructor
\item
\emph{version}: returns the version string
\item
\emph{cache\_init}: initializes the cache object
\item
\emph{seq\_init}: initializes the control\_seq object
\item
\emph{full\_mask}: returns a full control mask with or without bin durations
\item
\emph{error}: evaluates the error function and possibly its gradient
at the current point in the optimization space
\item
\emph{update\_controls}: updates the values controls selected in the
mask, marks the cache objects that depend on them stale
\item
\emph{cache\_refresh}: performs all queued computations in the cache
\item
\emph{cache\_fill}: invalidates the cache, recalculates everything
\item
\emph{X}: computes the state of the controlled system at a given time
\item
\emph{plot\_seq}: plots the control sequence
\item
\emph{plot\_stats}: plots the optimization statistics
\item
\emph{plot\_X}: plots the evolution of the system state as a function
of time. Only works for kets and state operators.
\item
\emph{analyze}: plots a report of the optimization run
\item
\emph{easy\_control}: quickly generates a reasonable set of initial
controls, random or not
\item
\emph{init\_opt}: initializes the optimization parameters and statistics
\item
\emph{search\_BFGS}: starts a BFGS optimization run with a given control mask
\item
\emph{ui\_open}: opens a UI window for monitoring the optimization progress
\item
\emph{monitor\_func}: callback for the optimization function, executed
once every iteration. Updates the UI window, decides whether the
optimization should stop here.
\item
\emph{shake}: slightly perturbs the current control sequence. Can be
used for escaping from local minima.
\item
\emph{import}: imports an array containing a control sequence (in
explicit physical units) into the current sequence
\item
\emph{export}: exports the current control sequence into an array with
explicit physical units
\end{itemize}


\subsubsection{Qsystem class}

The qsystem class contains the physical and/or mathematical
description of the bilinear control system we are trying to optimize.

\begin{itemize}
\item
\emph{qsystem}: constructor
\item
\emph{abstract\_representation}:
initializes an abstract bilinear control system
\item
\emph{hilbert\_representation}:
initializes a Hilbert space control system
\item
\emph{vec\_representation}:
initializes a Liouville space control system (in
the vec representation)
\item
\emph{set\_TU}:
sets the time unit, in seconds.
$\hat{A} = A \text{TU}$, $\hat{t} = t / \text{TU}$.
\item
\emph{set\_labels}:
defines some additional data about the system for the benefit of the
human user: description string, state and control labels.
\item
\emph{n\_ensemble}:
returns the number of systems in the ensemble sample
\end{itemize}

\subsubsection{Control sequence class}

The control\_seq class encapsulates a control sequence and the
transformation stack used to transform it.

\begin{itemize}
\item
\emph{control\_seq}: constructor
\item
\emph{n\_timeslots}:
returns the number of timeslots
\item
\emph{n\_controls}:
returns the number of control fields
\item
\emph{get}:
returns the current raw control fields corresponding to the given control mask
\item
\emph{set}:
sets the current raw control fields to the given values, transforms
them, computes the associated derivatives
\item
\emph{inv\_transform}:
performs the inverse control transform on the given set of control
field values, returns the resulting raw control values
\item
\emph{split}:
refines the sequence by splitting the given bins into several pieces
of equal duration
\item
\emph{integral}:
computes the time integrals of the control fields
\item
\emph{plot}:
plots the control field values
\end{itemize}

\subsubsection{Cache class}

The cache class computes and stores the generators and various propagators computed
for each time slice based on the data stored in qsystem and control\_seq.

\begin{itemize}
\item
\emph{cache}: constructor
\item
\emph{invalidate}:
invalidates the entire cache, forces a full recomputation of everything
\item
\emph{mark\_as\_stale}:
forces the recomputation of selected time slices
\item
\emph{refresh}:
recomputes all the cache objects that are both stale and needed
\item
\emph{g\_setup\_recalc}:
determines the optimal way to compute the $g$ object
\end{itemize}


\subsection{Unit tests}

\subsubsection{Test suite}
\emph{test\_suite.m} implements all the test optimization problems used in~\cite{machnes_2011}.
Given the number of the problem as input, it initializes a \DYNAMO{}
instance with the physics and optimization parameters of that particular problem.

\subsubsection{Gradient test}
Given a \DYNAMO{} instance, \emph{test\_gradient.m} tests whether a
given gradient function yields an accurate linearization of the
corresponding error function around the current point in the
optimization space.


\subsection{Utility functions}
In the \emph{utils} directory one can find the following utility functions:
\begin{itemize}
\item
\emph{}:
\end{itemize}

\subsection{Examples}
In the \emph{examples} directory we provide a number of examples of
how to use \DYNAMO{} to solve various optimization problems, to
serve as a tutorial for new users as well as to showcase the most important features.



\appendix
\section{Hilbert-Schmidt inner product}

We use the Hilbert-Schmidt inner product for both vectors and matrices:
\be
\inprod{X}{Y} := \tr\left(X^\dagger Y\right).
\ee
It induces the Frobenius norm:
\be
|X| := \sqrt{\inprod{X}{X}} = \sqrt{\tr\left(X^\dagger X\right)}.
\ee

If $X$ and $Y$ are Hermitian, $\inprod{X}{Y} \in \R$.

\section{$\cvec$ mapping}
\label{sec:vec}

The $\cvec$ function maps Hilbert space operators (square matrices) to
Liouville space vectors by stacking the columns of the matrix in order
from left to right into a column vector. This mapping is clearly
invertible, and we also have
\be
\cvec(A \rho B) = (B^T \otimes A) \cvec(\rho)
\ee
for any Hilbert space operators~$A, B$.
Consequently, the Liouville space equivalent~$\hat{U}$ for a unitary Hilbert space
propagator~$U$ is
\be
\label{eq:L-unitary}
\hat{U} := U^* \otimes U,
\ee
since
\be
\cvec(U \rho U^\dagger) = (U^* \otimes U) \cvec(\rho) = \hat{U} \cvec(\rho).
\ee
We then have for any~$A$,~$B$
\be
\label{eq:hat-product}
\inprod{\hat{A}}{\hat{B}}
= \tr((A^* \otimes A)^\dagger (B^* \otimes B))
= \tr((A^T B^*) \otimes (A^\dagger B))
%= \tr((A^\dagger B)^* \otimes (A^\dagger B))
= (\tr(A^\dagger B))^* \: \tr(A^\dagger B)
= |\inprod{A}{B}|^2.
\ee

The following property is also easy to verify:
\be
\inprod{\cvec(\rho)}{\cvec(\sigma)} = \cvec(\rho)^\dagger \cvec(\sigma)
= \tr(\rho^\dagger \sigma) = \inprod{\rho}{\sigma}.
\ee





\bibliography{dynamo}
\end{document}
